package io.horizen.utxo.csw

import io.horizen.cryptolibprovider.implementations.CswCircuitImplZendoo
import io.horizen.secret.{PrivateKey25519, PrivateKey25519Creator}
import io.horizen.utils.BytesUtils
import org.bouncycastle.math.ec.rfc8032.Ed25519
import org.junit.Assert.assertEquals
import org.junit.Test

import java.lang.reflect.Method
import java.nio.charset.StandardCharsets

class CswCircuitUtilsTest {
  val cswCircuit = new CswCircuitImplZendoo()

  @Test
  def transformPrivateKey25519(): Unit = {
    val pk: PrivateKey25519 = PrivateKey25519Creator.getInstance().generateSecret("seed".getBytes(StandardCharsets.UTF_8))

    val scalar = cswCircuit.privateKey25519ToScalar(pk)

    // Using reflection execute Bouncy castle method to generate Public key from the scalar
    // and verify that resulting PubKey is the same.
    val pubKey = new Array[Byte](32)
    val m: Method = classOf[Ed25519].getDeclaredMethod("scalarMultBaseEncoded", classOf[Array[Byte]], classOf[Array[Byte]], classOf[Int])
    m.setAccessible(true)
    m.invoke(classOf[Ed25519], scalar, pubKey, Integer.valueOf(0))

    assertEquals("Different public key than the one generated by BouncyCastle.",
      BytesUtils.toHexString(pk.publicImage().pubKeyBytes()), BytesUtils.toHexString(pubKey))

    // Regression
    assertEquals("Different pub key", "c50c85c213a1ec64ab56b4394a56720089dfebc87d091572250e44dee9bbac35", BytesUtils.toHexString(pk.publicImage().pubKeyBytes()))
    assertEquals("Different private key", "5145339a938b376be547e90e8ab5603bdbdf94a6e73daec73c393864f1c7b646", BytesUtils.toHexString(pk.privateKey()))
    assertEquals("Different transformation result", "506d13eaa8d9998f7b1fa0677a149f8f5ae2167ce5ee453d56aa913d8690d564", BytesUtils.toHexString(scalar))
  }
}
