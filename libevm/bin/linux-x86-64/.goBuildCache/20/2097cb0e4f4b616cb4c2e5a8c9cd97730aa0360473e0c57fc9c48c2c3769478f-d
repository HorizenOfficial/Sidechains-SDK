// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/paolo/.mvnGoLang/.go_path/pkg/mod/github.com/ethereum/go-ethereum@v1.10.26/crypto/secp256k1/scalar_mult_cgo.go:1:1
// Copyright 2015 Jeffrey Wilcke, Felix Lange, Gustav Simonsson. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found in
// the LICENSE file.

//go:build !gofuzz && cgo
// +build !gofuzz,cgo

package secp256k1

import (
	"math/big"
	"unsafe"
)

/*

#include "libsecp256k1/include/secp256k1.h"

extern int secp256k1_ext_scalar_mul(const secp256k1_context* ctx, const unsigned char *point, const unsigned char *scalar);

*/
import _ "unsafe"

func (BitCurve *BitCurve) ScalarMult(Bx, By *big.Int, scalar []byte) (*big.Int, *big.Int) {
	// Ensure scalar is exactly 32 bytes. We pad always, even if
	// scalar is 32 bytes long, to avoid a timing side channel.
	if len(scalar) > 32 {
		panic("can't handle scalars > 256 bits")
	}
	// NOTE: potential timing issue
	padded := make([]byte, 32)
	copy(padded[32-len(scalar):], scalar)
	scalar = padded

	// Do the multiplication in C, updating point.
	point := make([]byte, 64)
	readBits(Bx, point[:32])
	readBits(By, point[32:])

	pointPtr := (* /*line :40:16*/_Ctype_uchar /*line :40:23*/)(unsafe.Pointer(&point[0]))
	scalarPtr := (* /*line :41:17*/_Ctype_uchar /*line :41:24*/)(unsafe.Pointer(&scalar[0]))
	res := func() _Ctype_int{ _cgo0 := /*line :42:36*/context; var _cgo1 *_Ctype_uchar = /*line :42:45*/pointPtr; var _cgo2 *_Ctype_uchar = /*line :42:55*/scalarPtr; _cgoCheckPointer(_cgo0, nil); return _Cfunc_secp256k1_ext_scalar_mul(_cgo0, _cgo1, _cgo2); }()

	// Unpack the result and clear temporaries.
	x := new(big.Int).SetBytes(point[:32])
	y := new(big.Int).SetBytes(point[32:])
	for i := range point {
		point[i] = 0
	}
	for i := range padded {
		scalar[i] = 0
	}
	if res != 1 {
		return nil, nil
	}
	return x, y
}
