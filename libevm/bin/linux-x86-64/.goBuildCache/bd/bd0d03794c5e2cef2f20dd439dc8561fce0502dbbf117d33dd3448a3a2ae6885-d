// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/paolo/code/HorizenOfficial/Sidechains-SDK/libevm/main.go:1:1
package main

// // the following will be compiled by CGO and linked into the GO binary
// // this is not just a comment!
// #cgo CFLAGS: -g -Wall -O3 -fpic -Werror
// #include <stdlib.h>
// #include "main.h"
import _ "unsafe"
import (
	"fmt"
	"github.com/ethereum/go-ethereum/log"
	"libevm/interop"
	"libevm/lib"
	"unsafe"
)

// instance holds a singleton of lib.Service
var instance *lib.Service

// initialize logger
var logger = log.NewGlogHandler(log.FuncHandler(logToCallback))
var logFormatter = log.JSONFormatEx(false, false)
var logCallbackHandle int

func callbackProxy(handle int, args string) string {
	argsStr := ( /*line :26:13*/_Cfunc_CString /*line :26:21*/)(args)
	defer func() func() { _cgo0 := /*line :27:15*/unsafe.Pointer(argsStr); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	var result * /*line :28:14*/_Ctype_char /*line :28:20*/
	result = ( /*line :29:11*/_Cfunc_invokeCallbackProxy /*line :29:31*/)( /*line :29:33*/_Ctype_int /*line :29:38*/(handle), argsStr)
	defer func() func() { _cgo0 := /*line :30:15*/unsafe.Pointer(result); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	if result == nil {
		return ""
	}
	return ( /*line :34:9*/_Cfunc_GoString /*line :34:18*/)(result)
}

func logToCallback(r *log.Record) error {
	// see comments on stack.Call.Format for available format specifiers
	r.Ctx = append(r.Ctx,
		// path of source file
		"file", fmt.Sprintf("%+s", r.Call),
		// line number
		"line", fmt.Sprintf("%d", r.Call),
		// function name (without additional path qualifiers because the filename will already be qualified)
		"fn", fmt.Sprintf("%n", r.Call),
	)
	msg := string(logFormatter.Format(r))
	callbackProxy(logCallbackHandle, msg)
	return nil
}

// static initializer
func init() {
	// set default log level to trace
	logger.Verbosity(log.LvlTrace)
	log.Root().SetHandler(logger)
	// initialize instance of our service
	instance = lib.New()
	lib.SetCallbackProxy(callbackProxy)
}

// main function is required by cgo, but doesn't do anything nor is it ever called
func main() {
}

//export SetupLogging
func SetupLogging(handle int, level * /*line :67:38*/_Ctype_char /*line :67:44*/) {
	parsedLevel, err := log.LvlFromString(( /*line :68:40*/_Cfunc_GoString /*line :68:49*/)(level))
	if err != nil {
		log.Error("unable to parse log level", "error", err)
		return
	}
	logger.Verbosity(parsedLevel)
	logCallbackHandle = handle
}

//export Invoke
func Invoke(method * /*line :78:21*/_Ctype_char /*line :78:27*/, args * /*line :78:35*/_Ctype_char /*line :78:41*/) * /*line :78:44*/_Ctype_char /*line :78:50*/ {
	jsonString := interop.Invoke(instance, ( /*line :79:41*/_Cfunc_GoString /*line :79:50*/)(method), ( /*line :79:61*/_Cfunc_GoString /*line :79:70*/)(args))
	if jsonString == "" {
		return nil
	}
	return ( /*line :83:9*/_Cfunc_CString /*line :83:17*/)(jsonString)
}
