// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/paolo/.mvnGoLang/.go_path/pkg/mod/github.com/ethereum/go-ethereum@v1.10.26/crypto/secp256k1/secp256.go:1:1
// Copyright 2015 Jeffrey Wilcke, Felix Lange, Gustav Simonsson. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found in
// the LICENSE file.

//go:build !gofuzz && cgo
// +build !gofuzz,cgo

// Package secp256k1 wraps the bitcoin secp256k1 C library.
package secp256k1; import _cgo_unsafe "unsafe"

/*
#cgo CFLAGS: -I./libsecp256k1
#cgo CFLAGS: -I./libsecp256k1/src/

#ifdef __SIZEOF_INT128__
#  define HAVE___INT128
#  define USE_FIELD_5X52
#  define USE_SCALAR_4X64
#else
#  define USE_FIELD_10X26
#  define USE_SCALAR_8X32
#endif

#define USE_ENDOMORPHISM
#define USE_NUM_NONE
#define USE_FIELD_INV_BUILTIN
#define USE_SCALAR_INV_BUILTIN
#define NDEBUG
#include "./libsecp256k1/src/secp256k1.c"
#include "./libsecp256k1/src/modules/recovery/main_impl.h"
#include "ext.h"

typedef void (*callbackFunc) (const char* msg, void* data);
extern void secp256k1GoPanicIllegal(const char* msg, void* data);
extern void secp256k1GoPanicError(const char* msg, void* data);
*/
import _ "unsafe"

import (
	"errors"
	"math/big"
	"unsafe"
)

var context * /*line :45:14*/_Ctype_secp256k1_context /*line :45:33*/

func init() {
	// around 20 ms on a modern CPU.
	context = ( /*line :49:12*/_Cfunc_secp256k1_context_create_sign_verify /*line :49:49*/)()
	func() { _cgo0 := /*line :50:43*/context; var _cgo1 *[0]byte = _Ctype_callbackFunc /*line :50:66*/(_Cgo_ptr(_Cfpvar_fp_secp256k1GoPanicIllegal /*line :50:92*/)); var _cgo2 _cgo_unsafe.Pointer = /*line :50:95*/nil; _cgoCheckPointer(_cgo0, nil); _Cfunc_secp256k1_context_set_illegal_callback(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :51:41*/context; var _cgo1 *[0]byte = _Ctype_callbackFunc /*line :51:64*/(_Cgo_ptr(_Cfpvar_fp_secp256k1GoPanicError /*line :51:88*/)); var _cgo2 _cgo_unsafe.Pointer = /*line :51:91*/nil; _cgoCheckPointer(_cgo0, nil); _Cfunc_secp256k1_context_set_error_callback(_cgo0, _cgo1, _cgo2); }()
}

var (
	ErrInvalidMsgLen       = errors.New("invalid message length, need 32 bytes")
	ErrInvalidSignatureLen = errors.New("invalid signature length")
	ErrInvalidRecoveryID   = errors.New("invalid signature recovery id")
	ErrInvalidKey          = errors.New("invalid private key")
	ErrInvalidPubkey       = errors.New("invalid public key")
	ErrSignFailed          = errors.New("signing failed")
	ErrRecoverFailed       = errors.New("recovery failed")
)

// Sign creates a recoverable ECDSA signature.
// The produced signature is in the 65-byte [R || S || V] format where V is 0 or 1.
//
// The caller is responsible for ensuring that msg cannot be chosen
// directly by an attacker. It is usually preferable to use a cryptographic
// hash function on any input before handing it to this function.
func Sign(msg []byte, seckey []byte) ([]byte, error) {
	if len(msg) != 32 {
		return nil, ErrInvalidMsgLen
	}
	if len(seckey) != 32 {
		return nil, ErrInvalidKey
	}
	seckeydata := (* /*line :77:18*/_Ctype_uchar /*line :77:25*/)(unsafe.Pointer(&seckey[0]))
	if func() _Ctype_int{ _cgo0 := /*line :78:34*/context; var _cgo1 *_Ctype_uchar = /*line :78:43*/seckeydata; _cgoCheckPointer(_cgo0, nil); return _Cfunc_secp256k1_ec_seckey_verify(_cgo0, _cgo1); }() != 1 {
		return nil, ErrInvalidKey
	}

	var (
		msgdata   = (* /*line :83:17*/_Ctype_uchar /*line :83:24*/)(unsafe.Pointer(&msg[0]))
		noncefunc = ( /*line :84:15*/*_Cvar_secp256k1_nonce_function_rfc6979 /*line :84:48*/)
		sigstruct  /*line :85:13*/_Ctype_secp256k1_ecdsa_recoverable_signature /*line :85:52*/
	)
	if func() _Ctype_int{ _cgo0 := /*line :87:40*/context; var _cgo1 *_Ctype_struct___8 = /*line :87:49*/&sigstruct; var _cgo2 *_Ctype_uchar = /*line :87:61*/msgdata; var _cgo3 *_Ctype_uchar = /*line :87:70*/seckeydata; var _cgo4 *[0]byte = /*line :87:82*/noncefunc; var _cgo5 _cgo_unsafe.Pointer = /*line :87:93*/nil; _cgoCheckPointer(_cgo0, nil); return _Cfunc_secp256k1_ecdsa_sign_recoverable(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() == 0 {
		return nil, ErrSignFailed
	}

	var (
		sig     = make([]byte, 65)
		sigdata = (* /*line :93:15*/_Ctype_uchar /*line :93:22*/)(unsafe.Pointer(&sig[0]))
		recid    /*line :94:11*/_Ctype_int /*line :94:16*/
	)
	func() _Ctype_int{ _cgo0 := /*line :96:60*/context; var _cgo1 *_Ctype_uchar = /*line :96:69*/sigdata; var _cgo2 *_Ctype_int = /*line :96:78*/&recid; var _cgo3 *_Ctype_struct___8 = /*line :96:86*/&sigstruct; _cgoCheckPointer(_cgo0, nil); return _Cfunc_secp256k1_ecdsa_recoverable_signature_serialize_compact(_cgo0, _cgo1, _cgo2, _cgo3); }()
	sig[64] = byte(recid) // add back recid to get 65 bytes sig
	return sig, nil
}

// RecoverPubkey returns the public key of the signer.
// msg must be the 32-byte hash of the message to be signed.
// sig must be a 65-byte compact ECDSA signature containing the
// recovery id as the last element.
func RecoverPubkey(msg []byte, sig []byte) ([]byte, error) {
	if len(msg) != 32 {
		return nil, ErrInvalidMsgLen
	}
	if err := checkSignature(sig); err != nil {
		return nil, err
	}

	var (
		pubkey  = make([]byte, 65)
		sigdata = (* /*line :115:15*/_Ctype_uchar /*line :115:22*/)(unsafe.Pointer(&sig[0]))
		msgdata = (* /*line :116:15*/_Ctype_uchar /*line :116:22*/)(unsafe.Pointer(&msg[0]))
	)
	if func() _Ctype_int{ _cgo0 := /*line :118:35*/context; var _cgo1 *_Ctype_uchar = /*line :118:44*/(*_Ctype_uchar /*line :118:53*/)(unsafe.Pointer(&pubkey[0])); var _cgo2 *_Ctype_uchar = /*line :118:84*/sigdata; var _cgo3 *_Ctype_uchar = /*line :118:93*/msgdata; _cgoCheckPointer(_cgo0, nil); return _Cfunc_secp256k1_ext_ecdsa_recover(_cgo0, _cgo1, _cgo2, _cgo3); }() == 0 {
		return nil, ErrRecoverFailed
	}
	return pubkey, nil
}

// VerifySignature checks that the given pubkey created signature over message.
// The signature should be in [R || S] format.
func VerifySignature(pubkey, msg, signature []byte) bool {
	if len(msg) != 32 || len(signature) != 64 || len(pubkey) == 0 {
		return false
	}
	sigdata := (* /*line :130:15*/_Ctype_uchar /*line :130:22*/)(unsafe.Pointer(&signature[0]))
	msgdata := (* /*line :131:15*/_Ctype_uchar /*line :131:22*/)(unsafe.Pointer(&msg[0]))
	keydata := (* /*line :132:15*/_Ctype_uchar /*line :132:22*/)(unsafe.Pointer(&pubkey[0]))
	return func() _Ctype_int{ _cgo0 := /*line :133:38*/context; var _cgo1 *_Ctype_uchar = /*line :133:47*/sigdata; var _cgo2 *_Ctype_uchar = /*line :133:56*/msgdata; var _cgo3 *_Ctype_uchar = /*line :133:65*/keydata; var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :133:82*/(len(pubkey)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_secp256k1_ext_ecdsa_verify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() != 0
}

// DecompressPubkey parses a public key in the 33-byte compressed format.
// It returns non-nil coordinates if the public key is valid.
func DecompressPubkey(pubkey []byte) (x, y *big.Int) {
	if len(pubkey) != 33 {
		return nil, nil
	}
	var (
		pubkeydata = (* /*line :143:18*/_Ctype_uchar /*line :143:25*/)(unsafe.Pointer(&pubkey[0]))
		pubkeylen  =  /*line :144:16*/_Ctype_size_t /*line :144:24*/(len(pubkey))
		out        = make([]byte, 65)
		outdata    = (* /*line :146:18*/_Ctype_uchar /*line :146:25*/)(unsafe.Pointer(&out[0]))
		outlen     =  /*line :147:16*/_Ctype_size_t /*line :147:24*/(len(out))
	)
	if func() _Ctype_int{ _cgo0 := /*line :149:37*/context; var _cgo1 *_Ctype_uchar = /*line :149:46*/outdata; var _cgo2 _Ctype_size_t = /*line :149:55*/outlen; var _cgo3 *_Ctype_uchar = /*line :149:63*/pubkeydata; var _cgo4 _Ctype_size_t = /*line :149:75*/pubkeylen; _cgoCheckPointer(_cgo0, nil); return _Cfunc_secp256k1_ext_reencode_pubkey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == 0 {
		return nil, nil
	}
	return new(big.Int).SetBytes(out[1:33]), new(big.Int).SetBytes(out[33:])
}

// CompressPubkey encodes a public key to 33-byte compressed format.
func CompressPubkey(x, y *big.Int) []byte {
	var (
		pubkey     = S256().Marshal(x, y)
		pubkeydata = (* /*line :159:18*/_Ctype_uchar /*line :159:25*/)(unsafe.Pointer(&pubkey[0]))
		pubkeylen  =  /*line :160:16*/_Ctype_size_t /*line :160:24*/(len(pubkey))
		out        = make([]byte, 33)
		outdata    = (* /*line :162:18*/_Ctype_uchar /*line :162:25*/)(unsafe.Pointer(&out[0]))
		outlen     =  /*line :163:16*/_Ctype_size_t /*line :163:24*/(len(out))
	)
	if func() _Ctype_int{ _cgo0 := /*line :165:37*/context; var _cgo1 *_Ctype_uchar = /*line :165:46*/outdata; var _cgo2 _Ctype_size_t = /*line :165:55*/outlen; var _cgo3 *_Ctype_uchar = /*line :165:63*/pubkeydata; var _cgo4 _Ctype_size_t = /*line :165:75*/pubkeylen; _cgoCheckPointer(_cgo0, nil); return _Cfunc_secp256k1_ext_reencode_pubkey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == 0 {
		panic("libsecp256k1 error")
	}
	return out
}

func checkSignature(sig []byte) error {
	if len(sig) != 65 {
		return ErrInvalidSignatureLen
	}
	if sig[64] >= 4 {
		return ErrInvalidRecoveryID
	}
	return nil
}
