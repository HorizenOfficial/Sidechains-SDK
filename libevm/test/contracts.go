package test

import (
	_ "embed"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"math/big"
	"strings"
)

//go:generate solc --bin --bin-runtime --hashes --opcodes --storage-layout --optimize -o compiled --overwrite Storage.sol
//go:generate solc --bin --bin-runtime --hashes --opcodes --storage-layout --optimize -o compiled --overwrite OpCodes.sol
var (
	//go:embed compiled/Storage.bin
	storageDeployCode string
	//go:embed compiled/Storage.bin-runtime
	storageRuntimeCode string
	//go:embed compiled/Storage.signatures
	storageSignatures string

	//go:embed compiled/OpCodes.bin
	opCodesDeployCode string
	//go:embed compiled/OpCodes.bin-runtime
	opCodesRuntimeCode string
	//go:embed compiled/OpCodes.signatures
	opCodesSignatures string
)

// findSignature iterates the lines of a Signatures file generated by the Solidity compiler
// and returns the signature bytes of the first function containing the given pattern in its name
func findSignature(signatures, pattern string) []byte {
	signatures = strings.ToLower(signatures)
	pattern = strings.ToLower(pattern)
	for _, sig := range strings.Split(signatures, "\n") {
		if strings.Contains(sig, pattern) {
			return common.FromHex(sig[:8])
		}
	}
	panic(fmt.Sprintf("no function signature found for: %v", pattern))
}

func StorageContractDeploy(initialValue *big.Int) []byte {
	return append(common.FromHex(storageDeployCode), common.BigToHash(initialValue).Bytes()...)
}

func StorageContractRuntimeCode() []byte {
	return common.FromHex(storageRuntimeCode)
}

func StorageContractStore(value *big.Int) []byte {
	return append(findSignature(storageSignatures, "store"), common.BigToHash(value).Bytes()...)
}

func StorageContractRetrieve() []byte {
	return findSignature(storageSignatures, "retrieve")
}

func OpCodesContractDeploy() []byte {
	return common.FromHex(opCodesDeployCode)
}

func OpCodesContractRuntimeCode() []byte {
	return common.FromHex(opCodesRuntimeCode)
}

func OpCodesContractCall(name string) []byte {
	return findSignature(opCodesSignatures, name)
}
