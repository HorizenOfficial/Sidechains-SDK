package lib

import (
	"errors"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"libevm/lib/geth_internal"
	"math/big"
)

// ErrEmptyAccount is thrown when attempting to write to a storage trie of an otherwise "empty" account
// to prevent potential data loss, because empty accounts will be pruned, regardless of data in the storage trie
var ErrEmptyAccount = errors.New("account is empty, cannot modify storage trie")

// random data used to salt chunk keys in the storage trie when accessed via Get/SetStorageBytes, see getChunkKey
var chunkKeySalt = common.HexToHash("fa09428dd8121ea57327c9f21af74ffad8bfd5e6e39dc3dc6c53241a85ec5b0d").Bytes()

// chunk keys are generated by hashing a salt, the original key and the chunk index
// the salt was added to reduce the risk of accidental hash collisions because similar strategies
// to generate storage keys might be used by the caller
func getChunkKey(key common.Hash, chunkIndex int) common.Hash {
	return crypto.Keccak256Hash(chunkKeySalt, key.Bytes(), intToHash(chunkIndex).Bytes())
}

// convert integer to 256-bit hash value, takes care of serialization and padding (this will add leading zeros)
func intToHash(value int) common.Hash {
	return common.BigToHash(big.NewInt(int64(value)))
}

// convert 256-bit hash value to int, takes care of deserialization and padding
func hashToInt(hash common.Hash) int {
	return int(hash.Big().Int64())
}

// make sure we add trailing zeros, not leading zeroes
func bytesToHash(bytes []byte) common.Hash {
	if len(bytes) < common.HashLength {
		tmp := make([]byte, common.HashLength)
		copy(tmp, bytes)
		return common.BytesToHash(tmp)
	} else {
		return common.BytesToHash(bytes)
	}
}

type StorageParams struct {
	AccountParams
	Key common.Hash `json:"key"`
}

type SetStorageParams struct {
	StorageParams
	Value common.Hash `json:"value"`
}

type SetStorageBytesParams struct {
	StorageParams
	Value []byte `json:"value"`
}

type ProofParams struct {
	AccountParams
	StorageKeys []string `json:"storageKeys"`
}

func (s *Service) StateGetStorage(params StorageParams) (error, common.Hash) {
	err, statedb := s.statedbs.Get(params.Handle)
	if err != nil {
		return err, common.Hash{}
	}
	value := statedb.GetState(params.Address, params.Key)
	return nil, value
}

func (s *Service) StateSetStorage(params SetStorageParams) error {
	err, statedb := s.statedbs.Get(params.Handle)
	if err != nil {
		return err
	}
	s.setStateWithRefund(statedb, params.Address, params.Key, params.Value)
	return nil
}

func (s *Service) StateRemoveStorage(params StorageParams) error {
	err, statedb := s.statedbs.Get(params.Handle)
	if err != nil {
		return err
	}
	// the "empty" value will cause the key-value pair to be deleted
	s.setStateWithRefund(statedb, params.Address, params.Key, common.Hash{})
	return nil
}

func (s *Service) StateGetStorageBytes(params StorageParams) (error, []byte) {
	err, statedb := s.statedbs.Get(params.Handle)
	if err != nil {
		return err, nil
	}
	length := hashToInt(statedb.GetState(params.Address, params.Key))
	data := make([]byte, length)
	for start := 0; start < length; start += common.HashLength {
		chunkIndex := start / common.HashLength
		end := start + common.HashLength
		if end > length {
			end = length
		}
		chunk := statedb.GetState(params.Address, getChunkKey(params.Key, chunkIndex))
		copy(data[start:end], chunk.Bytes())
	}
	return nil, data
}

// StateSetStorageBytes writes values of arbitrary length to the storage trie of given account
// note: do not mix StateSetStorage and StateSetStorageBytes for the same key,
// this can potentially lead to dangling nodes in the storage Trie and de facto infinite-loops
func (s *Service) StateSetStorageBytes(params SetStorageBytesParams) error {
	err, statedb := s.statedbs.Get(params.Handle)
	if err != nil {
		return err
	}
	if statedb.Empty(params.Address) {
		// if the account is empty any changes would be dropped during the commit phase
		return fmt.Errorf("%w: %v", ErrEmptyAccount, params.Address)
	}
	// get previous length of value stored, if any
	oldLength := hashToInt(statedb.GetState(params.Address, params.Key))
	// values are split up into 32-bytes chunks:
	// the length of the value is stored at the original key and the chunks are stored at hash(key, i)
	newLength := len(params.Value)
	// if the new value is empty remove all key-value pairs, including the one holding the value length
	s.setStateWithRefund(statedb, params.Address, params.Key, intToHash(newLength))
	for start := 0; start < newLength || start < oldLength; start += common.HashLength {
		chunkIndex := start / common.HashLength
		var chunk common.Hash
		if start < newLength {
			end := start + common.HashLength
			if end > newLength {
				end = newLength
			}
			// (over-)write chunks
			chunk = bytesToHash(params.Value[start:end])
		} else {
			// remove previous chunks that are not needed anymore
			chunk = common.Hash{}
		}
		s.setStateWithRefund(statedb, params.Address, getChunkKey(params.Key, chunkIndex), chunk)
	}
	return nil
}

func (s *Service) StateRemoveStorageBytes(params StorageParams) error {
	deleteParams := SetStorageBytesParams{
		StorageParams: params,
		// the "empty" value will cause the key-value pair to be deleted
		Value: nil,
	}
	return s.StateSetStorageBytes(deleteParams)
}

func (s *Service) StateGetProof(params ProofParams) (error, *geth_internal.AccountResult) {
	err, statedb := s.statedbs.Get(params.Handle)
	if err != nil {
		return err, nil
	}
	result, err := geth_internal.GetProof(statedb, params.Address, params.StorageKeys)
	return err, result
}
