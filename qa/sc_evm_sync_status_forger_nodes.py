#!/usr/bin/env python3
import logging
import os
import re
import time
from datetime import datetime
from eth_utils import add_0x_prefix

from SidechainTestFramework.account.ac_chain_setup import AccountChainSetup
from SidechainTestFramework.account.ac_utils import ac_makeForgerStake
from SidechainTestFramework.account.utils import convertZenToZennies
from SidechainTestFramework.scutil import generate_next_blocks, \
    connect_sc_nodes, stop_sc_node, start_sc_node, wait_for_sc_node_initialization, \
    EVM_APP_BINARY, disconnect_sc_nodes_bi, generate_next_block
from test_framework.util import assert_equal, assert_true, fail, forward_transfer_to_sidechain

"""
Test the eth_syncing logic in a specific corner case: 
    forger node restarted that created few blocks (less then 100) and then is connected to the rest of the network 
    in this case the sync status actor will have no blocks internally that match when the one from the other nodes will came
    this will led to the actor restart
    The aim of this test is to run this case and be able to check the log generated by it.

Configuration:
    Start 1 MC nodes and 2 SC nodes.
"""

WITHDRAWAL_EPOCH_LENGTH = 10
websocket_server_port = 8026

class EvmSyncStatusForgerNodes(AccountChainSetup):
    number_of_mc_nodes = 1
    number_of_sidechain_nodes = 2

    def __init__(self):
        super().__init__(withdrawalEpochLength=20, number_of_sidechain_nodes=2, websocket_server_ports=[websocket_server_port, None])

    def check_sync_status(self, starting_block_height, execute_stop=False ):
        logging.info("Syncing...")
        t_0 = datetime.now()
        self.sync_sc_blocks(starting_block_height, execute_stop)
        t_1 = datetime.now()
        u_sec = (t_1 - t_0).microseconds
        sec = (t_1 - t_0).seconds
        logging.info("SC node 1 synced in {}.{} secs".format(sec, u_sec))

        node_check_blocks_density_freq = 15
        logging.info("Wait 30 seconds for SC node 1 to stop consider itself syncing")
        time.sleep(node_check_blocks_density_freq * 2)

        is_sync = self.sc_nodes[1].rpc_eth_syncing()["result"]
        logging.info("Current SC node 1 LAST sync info: " + str(is_sync))
        if type(is_sync) is bool and bool(is_sync):
            fail("SC node 1 still consider itself syncing")

    def sync_sc_blocks(self, starting_block_height, execute_stop=False, wait_for=200):
        # wait for maximum wait_for seconds for everybody to have the same block count
        start = time.time()
        sync_status = False
        while True:
            # call eth_syncing rpc method, if the sync status result is true check if the block values are correct
            res = self.sc_nodes[1].rpc_eth_syncing()["result"]
            logging.info("Current SC node 1 sync info: " + str(res))
            logging.info("SC node 1 height: " + str(self.sc_nodes[1].block_best()["result"]["height"]))
            logging.info("SC node 1 connections " + str(self.sc_nodes[1].node_connectedPeers()["result"]["peers"]))
            logging.info("SC node 0 connections " + str(self.sc_nodes[0].node_connectedPeers()["result"]["peers"]))
            if isinstance(res, dict) and "currentBlock" in res:
                sync_status = True

                decimal_starting_block = int(res["startingBlock"], 16)
                decimal_current_block = int(res["currentBlock"], 16)
                decimal_highest_block = int(res["highestBlock"], 16)

                # assert_equal(starting_block_height, decimal_starting_block, "unexpected value for startingBlock")

                assert_true(decimal_current_block > 0, "unexpected value for currentBlock")
                assert_true(decimal_current_block >= decimal_starting_block, "startingBlock > currentBlock")

                assert_true(decimal_highest_block > 0, "unexpected value for highestBlock")
                assert_true(decimal_highest_block - decimal_current_block > 0, "currentBlock >= highestBlock")
                assert_true(decimal_highest_block - decimal_starting_block > 0, "startingBlock >= highestBlock")
            elif sync_status:
                # Received status false after it was true for some period of time
                sync_status = False
                break

            if time.time() - start >= wait_for:
                fail("Syncing blocks timeout")

            counts = [int(x.block_best()["result"]["height"]) for x in self.sc_nodes]
            if counts == [counts[0]] * len(counts):
                break

            # Stop node 0 after 15 seconds in execute_stop was set
            if execute_stop and time.time() - start >= 15:
                logging.info("Disconnect sidechain nodes")
                disconnect_sc_nodes_bi(self.sc_nodes, 0, 1)
                logging.info("Stopping SC node 0")
                stop_sc_node(self.sc_nodes[0], 0)
                break

            time.sleep(1)

        if not sync_status:
            fail("SC node 1 was in sync but has not detected that it is in sync")

    def run_sc_node(self, sc_node_idx):
        logging.info("Starting SC node " + str(sc_node_idx))
        start_sc_node(sc_node_idx, self.options.tmpdir, binary=EVM_APP_BINARY)
        wait_for_sc_node_initialization(self.sc_nodes)
        time.sleep(3)

    def restart_sc_node(self, sc_node_idx):
        logging.info("Stopping SC node " + str(sc_node_idx))
        stop_sc_node(self.sc_nodes[sc_node_idx], sc_node_idx)
        time.sleep(2)

        self.run_sc_node(sc_node_idx)

    def run_test(self):
        sc_node0 = self.sc_nodes[0]
        sc_node1 = self.sc_nodes[1]
        self.sc_ac_setup()

        # Send a FT to the SC node 2 and make it a forger node
        logging.info("Send a FT to the SC node 2")
        sc_node1_address = sc_node1.wallet_createPrivateKeySecp256k1()["result"]["proposition"]["address"]

        forward_transfer_to_sidechain(self.sc_nodes_bootstrap_info.sidechain_id,
                                      self.nodes[0],
                                      sc_node1_address,
                                      50,
                                      self.mc_return_address)

        self.block_id = generate_next_block(sc_node0, "node 0", force_switch_to_next_epoch=True)
        self.sc_sync_all()

        sc_node1_vrfPubKey = sc_node1.wallet_createVrfSecret()["result"]["proposition"]["publicKey"]
        sc_node1_blockSignPubKey = sc_node1.wallet_createPrivateKey25519()["result"]["proposition"]["publicKey"]

        result = ac_makeForgerStake(sc_node1, sc_node1_address, sc_node1_blockSignPubKey, sc_node1_vrfPubKey,
                                    convertZenToZennies(33))
        self.sc_sync_all()

        generate_next_block(sc_node0, "node 0")
        self.sc_sync_all()

        # Checking the receipt
        tx_id = result['result']['transactionId']
        receipt = sc_node1.rpc_eth_getTransactionReceipt(add_0x_prefix(tx_id))
        status = int(receipt['result']['status'], 16)
        assert_equal(1, status, "Make forger stake with native smart contract as owner should create a failed tx")

        self.block_id = generate_next_block(sc_node0, "node 0", force_switch_to_next_epoch=True)
        self.sc_sync_all()

        self.block_id = generate_next_block(sc_node0, "node 0", force_switch_to_next_epoch=True)
        self.sc_sync_all()

        # -------------------------------------------------------------------------------------
        # Test
        # the test workflow is:
        # disconnect SC0 and SC1
        # generate 200 blocks on SC0
        # stop SC0
        # restart SC1
        # generate 3 blocks on SC1 to fill the sync status actor with new blocks
        # reconnect SC0 and SC1

        # disconnect node 1
        logging.info("Disconnect SC node 0 and SC node 1")
        disconnect_sc_nodes_bi(self.sc_nodes, 0, 1)
        time.sleep(5)

        # generate 200 blocks on node 0
        logging.info("SC node 0 generates {} blocks...".format(200))
        generate_next_blocks(sc_node0, "node 0", 200, verbose=False)

        # check the block height on the different nodes
        sc_node_0_height = int(sc_node0.block_best()["result"]["height"])
        print('NODE 0 HEIGHT')
        print(sc_node_0_height)
        sc_node_1_height = int(sc_node1.block_best()["result"]["height"])
        print('NODE 1 HEIGHT')
        print(sc_node_1_height)

        # stop the node 1
        logging.info("Stopping SC node 1")
        stop_sc_node(sc_node1, 1)
        time.sleep(30)

        # restart the node 1 and generate 3 blocks
        self.run_sc_node(1)
        generate_next_blocks(sc_node1, "node 1", 3, verbose=False)
        time.sleep(30)

        # check the block height on the different nodes
        sc_node_0_height = int(sc_node0.block_best()["result"]["height"])
        print('NODE 0 HEIGHT')
        print(sc_node_0_height)
        sc_node_1_height = int(sc_node1.block_best()["result"]["height"])
        print('NODE 1 HEIGHT')
        print(sc_node_1_height)

        # reconnect the nodes
        connect_sc_nodes(self.sc_nodes[0], 1)
        self.sync_all()
        time.sleep(30)

        # check the block height on the different nodes
        print('NODE 0 HEIGHT')
        print(sc_node_0_height)
        sc_node_1_height = int(sc_node1.block_best()["result"]["height"])
        print('NODE 1 HEIGHT')
        print(sc_node_1_height)

        # check the warn message in the log file
        os.chdir(self.options.tmpdir + "/sc_node1/log")
        pattern = r'\bSyncStatusActor: unexpected new tip ([a-zA-Z0-9-]+) appeared due to recent node restart\b'
        pattern_match = False
        with open('debugLog.txt', 'r') as file:
            for line in file:
                match = re.search(pattern, line)
                if match:
                    pattern_match = True
        assert_true(pattern_match)

if __name__ == "__main__":
    EvmSyncStatusForgerNodes().main()
